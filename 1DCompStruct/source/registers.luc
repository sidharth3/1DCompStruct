module registers ( //module which contains all the contents of the 4 registers, shifts them for each clockcycle and sends them to the color mapping module to out a rgb code
    input clk,  // clock
    input rst,  // reset
    input shift,
    input reset,
    input set[1],
    output l1[8],
    output l2[8],
    output lane1val[2],
    output lane2val[2],
    output lane3val[2],
    output lane4val[2],
    output row1[4][24],
    output row2[4][24],
    output row3[4][24],
    output row4[4][24],
    output row5[4][24],
    output out[8],
    output level[3],
    output levelUp[1]
  ) {
  alu alu1;
  alu alu2;
  alu alu3;
  alu alu4;  
  map map;
  ledrow1map ledrow1map;
  ledrow2map ledrow2map;
  ledrow3map ledrow3map;
  ledrow4map ledrow4map;
  ledrow5map ledrow5map;
 
  sig templane1[10];
  sig templane2[10];
  sig templane3[10];
  sig templane4[10];
  .clk(clk){
 .rst(rst){
   dff addr[6];
   dff lane1[10];
   dff lane2[10];
   dff lane3[10];
   dff lane4[10];
   dff levelReg[3];
   smallgc ctr;
      }
   }
  always {
    l1 = lane3.q[7:0];
    l2= lane4.q[7:0];
    ledrow1map.lane1 = lane1.q;
    ledrow1map.lane2 = lane2.q;
    ledrow1map.lane3 = lane3.q;
    ledrow1map.lane4 = lane4.q;
    ledrow2map.lane1 = lane1.q;
    ledrow2map.lane2 = lane2.q;
    ledrow2map.lane3 = lane3.q;
    ledrow2map.lane4 = lane4.q;
    ledrow3map.lane1 = lane1.q;
    ledrow3map.lane2 = lane2.q;
    ledrow3map.lane3 = lane3.q;
    ledrow3map.lane4 = lane4.q;
    ledrow4map.lane1 = lane1.q;
    ledrow4map.lane2 = lane2.q;
    ledrow4map.lane3 = lane3.q;
    ledrow4map.lane4 = lane4.q;
    ledrow5map.lane1 = lane1.q;
    ledrow5map.lane2 = lane2.q;
    ledrow5map.lane3 = lane3.q;
    ledrow5map.lane4 = lane4.q;
    
    row1 = ledrow1map.color_row1;
    row2 = ledrow2map.color_row2;
    row3 = ledrow3map.color_row3;
    row4 = ledrow4map.color_row4;
    row5 = ledrow5map.color_row5;
    ctr.reset = 0;
    map.address = 0;
    alu1.a = 0;
    alu1.b = 0;
    alu1.alufn = 6b0000000;
    alu2.a = 0;
    alu2.b = 0;
    alu2.alufn = 6b0000000;
    alu3.a = 0;
    alu3.b = 0;
    alu3.alufn = 6b0000000;
    alu4.a = 0;
    alu4.b = 0;
    alu4.alufn = 6b0000000;
    lane1val = lane1.q[9:8];
    lane2val = lane2.q[9:8];
    lane3val = lane3.q[9:8];
    lane4val = lane4.q[9:8];
    if(reset){
      levelReg.d = b01;
      addr.d = 0;
      lane1.d = 10b0;
      lane2.d = 10b0;
      lane3.d = 10b0;
      lane4.d = 10b0;
      }
// case (levels.q){
//     levels.LEVEL1:
//       map.level = b01;
//       //io_led[1] = b01;
//       if (map.next_row == 8x{b1}){
//       ctr.reset = 1;
//       levels.d = levels.LEVEL2;      
//       }
//     levels.LEVEL2:
//       map.level = b10;
//       //io_led[1] = b10;
//       if (map.next_row == 8x{b1}){
//       ctr.reset = 1;
//       levels.d = levels.LEVEL3;      
//      }
//     levels.LEVEL3:
//       map.level = b11;
//       //io_led[1] = b11;
//       if (map.next_row == 8x{b1}){
//       ctr.reset = 1;
//       levels.d = levels.IDLE;      
//      }
//     default:
//       map.level = b00;
//       //io_led[1] = 8x{b1};
//     }
      map.set = set;
      map.level = levelReg.q;
      if (levelReg.q == b0){
      levelReg.d = b01;
    }
      level = levelReg.q;
      levelUp = 0;
      out = map.next_row;
      map.address = addr.q;
      if(map.next_row == 8b11111111){
        levelReg.d = levelReg.q+1;
        addr.d = 0;
        levelUp = 1;
      }
      if(shift==1){
        templane1 = lane1.q << 2;
        lane1.d = c{templane1[9:2],map.next_row[1:0]};
        templane2 = lane2.q << 2;
        lane2.d = c{templane2[9:2],map.next_row[3:2]};
        templane3 = lane3.q << 2;
        lane3.d = c{templane3[9:2],map.next_row[5:4]};
        templane4 = lane4.q << 2;
        lane4.d = c{templane4[9:2],map.next_row[7:6]}; 
      
        // go the next address  
        addr.d = addr.q + 1;
      
        // need to do checking for the kill signal
        }
      }
  }

