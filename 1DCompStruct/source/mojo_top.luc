global Color {
    // BGR
    const RED = h00DD00;
    const GREEN = h0000DD;
    const BLUE = hDD0000;
    const YELLOW = h008888;
    const WHITE = h888888;
    const BLACK = h000000;
}

module mojo_top (
    input clk,              // 50MHz clock
    input rst_n,            // reset button (active low)
    output led [8],         // 8 user controllable LEDs
    input cclk,             // configuration clock, AVR ready when high
    output spi_miso,        // AVR SPI MISO
    input spi_ss,           // AVR SPI Slave Select
    input spi_mosi,         // AVR SPI MOSI
    input spi_sck,          // AVR SPI Clock
    output spi_channel [4], // AVR general purpose pins (used by default to select ADC channel)
    input avr_tx,           // AVR TX (FPGA RX)
    output avr_rx,          // AVR RX (FPGA TX)
    input avr_rx_busy,      // AVR RX buffer full
    output io_led [3][8],   // LEDs on IO Shield
    output io_seg [8],      // 7-segment LEDs on IO Shield
    output io_sel [4],      // Digit select on IO Shield
    input io_button [5],    // 5 buttons on IO Shield
    input io_dip [3][8],     // DIP switches on IO Shield
    output a,
    output b,
    output c,
    input player2left,
    input player2right,
    input player1left,
    input player1right
    //output leddata[11]
  ) {
 
  sig mySig;
  sig rst;                  // reset signal
  sig button;
  sig level[2];
  const COLUMNS = 4;
  const ROWS = 6;
  
  
  const T1 = 10b1000000011;
  const T2 = 10b1000000011;
  const T3 = 10b1000000001;
  const T4 = 10b1000000000;
  
  .clk(clk) {
    // The reset conditioner is used to synchronize the reset signal to the FPGA
    // clock. This ensures the entire FPGA comes out of reset at the same time.
     //car car1;
     //car car2;;
    //car car2;
    //color_map clrm;

   // .rst(rst){forled tmp;}
    reset_conditioner reset_cond;
    //button_conditioner button_cond;
    //edge_detector edge_detector (#RISE(1), #FALL(0));
    fsm states = {IDLE, SHIFT, CHECKINPUT, CHECKCOLLISION, GENERATE, FAIL};
    //forled temp;
 ////   dff t1(#INIT(1000000010));
   // dff t2(#INIT(0000000001));
   // dff t3(#INIT(0000000000));
   // dff t4(#INIT(0000000010));
    dff start;
    //dff led_matrix_temp[ROWS][COLUMNS];
    
    fsm levels = {LEVEL1, LEVEL2, LEVEL3,IDLE};    
    .rst(rst){
        //ledmatrix led_matrix(#COLUMNS(COLUMNS), #ROWS(ROWS))
        smallgc count;
      }
    
  }

map map;
  always {
    reset_cond.in = ~rst_n; // input raw inverted reset signal
    rst = reset_cond.out;   // conditioned reset
    
    led = 8h00;             // turn LEDs off
    spi_miso = bz;          // not using SPI
    spi_channel = bzzzz;    // not using flags
    avr_rx = bz;            // not using serial port
    
    io_led = 3x{{8h00}};    // turn LEDs off
    io_seg = 8hff;          // turn segments off
    io_sel = 4hf;           // select no digits
    a = 1;
    b = 0;
    c = 0;
    //tempmat.d[0] = b10;
    //tempmat.d[1] = tempmat.q[0];
    // clrm.lane4 = T4;
    // clrm.lane3 = T3;
    // clrm.lane2 = T2;
    // clrm.lane1 = T1;
    //  tmp.update = 1;
    // clrm.rst = rst;
    //tmp.color = {24b111111110000000000000000, 24b0000000011111111100000000, 24b000000000000000011111111, 24x{b1}};
  //  tmp.color = clrm.color_row;
    // io_led[0] = clrm.cc1;
    // io_led[1] = clrm.cc2;
    //tmp.color = c{16b0,8b1};
//c = tmp.led;
  //  io_led[0][0] = io_dip[0][0];
    //case(state)
    //state.idle:
      //if(rise == 1  
    count.reset = 0;
 
    map.level = b11;
    map.address = count.out;
    io_led[1] = b11;
    io_led[0] = map.next_row;
    io_led[2] = count.out;
    if (map.next_row == 8x{b1}){
    count.reset = 1;
    }
  }
}